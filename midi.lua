---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ninovanhooff.
--- DateTime: 22/07/2022 14:45
---

import "./SampleCache.lua"

local masterplayer <const> = masterplayer
local lume <const> = masterplayer.lume
local snd <const> = playdate.sound
local defaultSampledVolume <const> = 0.5
local defaultWaveVolume <const> = 0.2
local defaultWaveAttack <const> = 0
local defaultWaveDecay <const> = 0.15
local defaultWaveSustain<const> = 0.2
local defaultWaveRelease <const> = 0

function masterplayer.newWaveSynth(trackProps)
    local s = snd.synth.new(trackProps.instrument.source or snd.kWaveSawtooth)
    s:setVolume(trackProps.volume or defaultWaveVolume)
    s:setADSR(
        trackProps.attack or defaultWaveAttack,
        trackProps.decay or defaultWaveDecay, 
        trackProps.sustain or defaultWaveSustain, 
        trackProps.release or defaultWaveRelease
    )
    return s
end

function masterplayer.createSampleSynth(samplePath, trackProps)
    print(samplePath)
    local sample = masterplayer.sampleCache:getOrLoad(samplePath)
    if not sample then
        error("sample not found: " .. samplePath)
    end
    local s = snd.synth.new(sample)
    s:setVolume(trackProps.volume or defaultSampledVolume)
    -- no drum defaults yet, use wave defaults
    s:setADSR(
        trackProps.attack or defaultWaveAttack,
        trackProps.decay or defaultWaveDecay,
        trackProps.sustain or defaultWaveSustain,
        trackProps.release or defaultWaveRelease
    )
    return s
end

function masterplayer.createWaveInstrument(polyphony, trackProps)
    local inst = snd.instrument.new()
    for _=1, polyphony do
        inst:addVoice(masterplayer.newWaveSynth(trackProps))
    end
    return inst
end

function masterplayer.createSampledInstrument(trackProps)
    local inst = snd.instrument.new()
    local instrumentDir = trackProps.instrument.source
    local instrumentProps = playdate.file.run(instrumentDir .. "instrumentProps")
    local synth, noteProps, transpose, noteStart, noteEnd, noteRoot, offset
    local addedNoteProps = {}
    for _, note in ipairs(trackProps.notes) do
        noteProps = instrumentProps[note]
        if noteProps then
            if not lume.find(addedNoteProps, noteProps) then
                noteStart = noteProps.noteStart or note
                noteEnd = noteProps.noteEnd or noteStart
                noteRoot = noteProps.noteRoot or noteStart
                offset = noteRoot - noteStart
                transpose = 60 - noteStart - offset-- the default noteRoot is C4 (midi note 60)
                synth = masterplayer.createSampleSynth( instrumentDir .. noteProps.path, trackProps)
                inst:addVoice(synth, noteStart, noteEnd, transpose )
                table.insert(addedNoteProps, noteProps)
            end
        else
            print("instrument does not support note " .. note)
        end
    end
    return inst
end

function masterplayer.createInstrument(polyphony, trackProps)
    if type(trackProps.instrument.source) == "string" then
        return masterplayer.createSampledInstrument(trackProps)
    else
        return masterplayer.createWaveInstrument(polyphony, trackProps)
    end
end

local function getNotesForTrack(track)
    local notes = {}
    for _, item in ipairs(track:getNotes(1, track:getLength())) do
        notes[item.note] = true
    end
    return lume.sort(lume.keys(notes))
end

local function createTrackProps(s)
    local numTracks = s:getTrackCount()
    local trackProps = {}
    local active = {}
    local poly = 0

    for i=1,numTracks do
        local track = s:getTrackAtIndex(i)
        if track ~= nil then
            local polyphony = track:getPolyphony()
            if polyphony > 0 then active[#active+1] = i end
            if polyphony > poly then poly = polyphony end
            print("track "..i.." has polyphony ".. polyphony)

            local notes = getNotesForTrack(track)
            local props = {
                isMuted = #notes < 1,
                isSolo = false,
                notes = notes
            }
            trackProps[i] = props

            print("Creating Sawtooth for track", i)
            props.instrument = masterplayer.sawToothInstrument
            props.volume = defaultWaveVolume
            props.attack = defaultWaveAttack
            props.decay = defaultWaveDecay
            props.sustain = defaultWaveSustain
            props.release = defaultWaveRelease
            local inst = masterplayer.createWaveInstrument(polyphony, trackProps[i])
            track:setInstrument(inst)
        end
    end

    return trackProps
end

function masterplayer.loadTrackProps(s, trackProps)
    local numTracks = s:getTrackCount()
    for i=1,numTracks do
        local track = s:getTrackAtIndex(i)
        if not trackProps[i].notes then
            trackProps[i].notes = getNotesForTrack(track)
        end
        if track ~= nil then
            local polyphony = track:getPolyphony()
            track:setInstrument(masterplayer.createInstrument(polyphony, trackProps[i]))
        end
    end
    return trackProps
end

function masterplayer.loadMidi(path, _trackProps)
    local trackProps = _trackProps or {}
    local s = snd.sequence.new(path)
    local ntracks = s:getTrackCount()
    print("ntracks", ntracks)

    if ntracks == #trackProps then
        return s, masterplayer.loadTrackProps(s, trackProps)
    else
        print("Creating track props for", path)
        return s, createTrackProps(s)
    end
end
